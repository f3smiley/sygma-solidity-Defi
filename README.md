## Sygma X Solidity

### Architecture

Sygma X has three parts:
 - router 
 - executor
 - block header storage

#### Router

Handles all incoming deposits, raises a deposit event for indexers and stores the transfer hash (can be optimized) for proving on destination.

#### Executor

Handles proposal executions on the destination chain. Accepts proposal data with the state inclusion proofs and executes application logic based on the type of proposal. Proposal cannot be executed if the block header is not already on-chain.

#### Block header storage

Stores finalized block headers (or more correctly their state roots) and makes them available to the executor.

### Flow

User deposits on the `Router` contract. Block header oracles index the deposit and process and submit the block header on the appropriate chain in the `BlockStorage` contract. Data transport layer indexes the block header subsmissions and submits the application data with the inclusion proof on the `Executor` contract for the proposals that are ready.

### State proofs

Slot key created by creating a hash of concated 32 bytes of:
 - map index
 - slot index (brute force value by going from 0 and find where the storage is not empty and contains the expected value)

Example of slot key for deposit nonce 1 and slot index 1: 
 - `00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001`


### Proof submitted on chain

Proofs can be generated by calling `eth_getProof` on an archive node (full node returns proof only for the latest block).

Example:
```
{"jsonrpc":"2.0","method":"eth_getProof","params":["0xFF22eEF6FF342bf8531f90ab377cd6A4b7a8D1D4",["0xcc69885fda6bcc1a4ace058b4a62bf5e179ea78fd58a1ccd71c22cc9b688792f"], "0x91FB9A"],"id":1}
```
Params are: 
 - ethereum account address
 - [slot key, blockNumber]

Proof submitted on chain is then generated by abi encoding:
 - block number (uint)
 - account proof (bytes[])
 - storage proof (bytes[])

** Note - Potential upgrade is to batch executions from one chain for a interval of blocks and submit one account proof per batch and storage proof for each proposal